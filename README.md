# Основные команды Git <br>
## Инициализация репозитория <br>
- *git init* (от англ. initialize, «инициализировать») — инициализируй репозиторий. <br>
## Синхронизация локального и удалённого репозиториев <br>
- *git remote add origin https://github.com/YandexPracticum/first-project.git* (от англ. remote, «удалённый» + add, «добавить») — привяжи локальный репозиторий к удалённому с URL *https://github.com/YandexPracticum/first-project.git*; <br>
- *git remote -v* (от англ. verbose, «подробный») — проверь, что репозитории действительно связались; <br>
- *git push -u origin main* (от англ. push, «толкать») — в первый раз загрузи все коммиты из локального репозитория в удалённый с названием *origin*. <br>
*Ваша ветка может называться master, а не main. Подправьте команду, если это необходимо.* <br>
- *git push* (от англ. push, «толкать») — загрузи коммиты в удалённый репозиторий после того, как он был привязан с помощью флага *-u*. <br>
## Подготовка файла к коммиту <br>
- *git add todo.txt* (от англ. add, «добавить») — подготовь файл *todo.txt* к коммиту; <br>
- *git add --all* (от англ. add, «добавить» + all, «всё») — подготовь к коммиту сразу все файлы, в которых были изменения, и все новые файлы; <br>
- *git add .* — подготовь к коммиту текущую папку и все файлы в ней. <br>
## Создание и публикация коммита <br>
- *git commit -m "Комментарий к коммиту."* (от англ. commit, «совершать», фиксировать» + message, «сообщение») — сделай коммит и оставь комментарий, чтобы было проще понять, какие изменения сделаны; <br>
- *git push* (от англ. push, «толкать») — добавь изменения в удалённый репозиторий. <br>
## Просмотр информации о коммитах <br>
- *git log* (от англ. log, «журнал [записей]») — выведи подробную историю коммитов; <br>
- *git log* --oneline (от англ. log, «журнал [записей]» + oneline, «одной строкой») — покажи краткую информацию о коммитах: сокращённый хеш и сообщение. <br>
## Просмотр состояния файлов <br>
- *git status* (от англ. status, «статус», «состояние») — покажи текущее состояние репозитория. <br>
## Добавление изменений в последний коммит <br>
- *git commit --amend --no-edit* (от англ. amend, «исправить») — добавь изменения к последнему коммиту и оставь сообщение прежним; <br>
- *git commit --amend -m "Новое сообщение"* — измени сообщение к последнему коммиту на *Новое сообщение*. <br>
*Выйти из редактора Vim: нажать Esc, ввести :qa!, нажать Enter.* <br>
## «Откат» файлов и коммитов <br>
- *git restore --staged hello.txt* (от англ. restore, «восстановить») — переведи файл *hello.txt* из состояния *staged* обратно в *untracked* или *modified*; <br>
- *git restore hello.txt* — верни файл *hello.txt* к последней версии, которая была сохранена через *git commit* или *git add*; <br>
- *git reset --hard b576d89* (от англ. reset, «сброс», «обнуление» + hard, «суровый») — удали все незакоммиченные изменения из staging и «рабочей зоны» вплоть до указанного коммита. <br>
## Просмотр изменений <br>
- *git diff* (от англ. difference, «отличие», «разница») — покажи изменения в «рабочей зоне», то есть в *modified*-файлах; <br>
- *git diff a9928ab 11bada1* — выведи разницу между двумя коммитами; <br>
- *git diff --staged* — покажи изменения, которые добавлены в *staged*-файлах. <br>
## Шпаргалка по MarkDown <br>
- https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c#h1 <br>
# Работа с ветками <br>
## Клонирование чужого репозитория <br>
- *git clone git@github.com:YandexPraktikum/first-project.git* (от англ. clone, «клон», «копия») — склонируй репозиторий с URL *first-project.git* из аккаунта *YandexPraktikum* на мой локальный компьютер. <br>
## Создание веток <br>
- *git branch feature/the-finest-branch* (от англ. branch, «ветка») — создай ветку от текущей с названием *feature/the-finest-branch*; <br>
- *git checkout -b feature/the-finest-branch* — создай ветку *feature/the-finest-branch* и сразу переключись на неё. <br>
## Навигация по веткам <br>
- *git branch* (от англ. branch, «ветка») — покажи, какие есть ветки в репозитории и в какой из них я нахожусь (текущая ветка будет отмечена символом ***); <br>
- *git branch -a* — покажи все известные ветки, как локальные (в локальном репозитории), так и удалённые (в *origin*, или на GitHub). <br>
- *git checkout feature/br* — переключись на ветку *feature/br*. <br>
## Сравнение веток <br>
- *git diff main HEAD* (от англ. difference, «отличие», «разница») — покажи разницу между веткой *main* и указателем на *HEAD*; <br>
- *git diff HEAD~2 HEAD* — покажи разницу между тем коммитом, который был два коммита назад, и текущим. <br>
## Удаление веток <br>
- *git branch -d br-name* — удали ветку *br-name*, но только если она является частью *main*; <br>
- *git branch -D br-name* — удали ветку *br-name*, даже если она не объединена с *main*. <br>
## Слияние веток <br>
- *git merge main* (от англ. merge, «сливать», «поглощать») — объедини ветку *main* с текущей активной веткой. <br>
## Работа с удалённым репозиторием <br>
- *git push -u origin my-branch* (от англ. push, «толкнуть», «протолкнуть») — отправь новую ветку *my-branch* в удалённый репозиторий и свяжи локальную ветку с удалённой, чтобы при дополнительных коммитах можно было писать просто *git push без -u*; <br>
- *git push my-branch* — отправь дополнительные изменения в ветку *my-branch*, которая уже существует в удалённом репозитории; <br>
- *git pull* (от англ. pull, «вытянуть») — подтяни изменения текущей ветки из удалённого репозитория. <br>
# Командная работа в Git <br>
## Feature branch workflow <br>
 	Самый популярный подход к работе с Git в команде — это feature branch workflow. В нём создают ветку для каждой задачи (например, для новой функциональности или исправления бага),  
 а когда всё готово, вливают новую ветку в *main*. <br>
 	Важные этапы этого процесса — пул-реквест и ревью изменений. Пул-реквест — это интерфейс, в котором можно обсудить изменения.  
 Ревью — просмотр изменений другими участниками и один из способов проверить качество таких изменений. <br>
 	Если вы уже участник проекта (или collaborator в терминах GitHub), можно клонировать репозиторий напрямую.  
 А если нет, нужно предварительно сделать «форк». Также для участников доступна кнопка Merge после ревью, а для неучастников — нет. <br>
## Конфликты слияния <br>
 Когда один и тот же файл меняется в нескольких ветках, при их слиянии может произойти конфликт.  
 Пугаться конфликтов не нужно, это нормальная часть работы с системами контроля версий.  
 IDE, вроде VSCode или Intellij IDEA, помогут «склеить» файл из двух конфликтующих версий. <br>
## Алгоритм-шпаргалка для создания PR <br>
1. Склонировать репозиторий.  
 1.1. Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.  
 1.2. На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.  
 1.3. Выполнить команду *git clone <ссылка на репозиторий>*.  
2. Создать ветку для вашей задачи: *git checkout -b my-task-branch-name*.  
3. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.    
4. «Запушить» ветку: *git push --set-upstream origin HEAD* или *git push -u origin my-task-branch-name*.  
 4.1. GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.  
 4.2. PR можно также создать через интерфейс GitHub.  
5. Сообщить о пул-реквесте ревьюеру.  
 5.1. Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.  
6. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).  
 6.1. Если кто-то добавил конфликтующие изменения в *main*, пока ваш PR был на ревью, нужно разрешить конфликт:  
  - Обновить *main*: *git checkout main && git pull*.  
  - Влить *main* в свою ветку: *git checkout my-task-branch-name && git merge main*.  
  - Разрешить конфликты слияния с помощью IDE или вручную.  
  - Создать коммит слияния: *git commit --no-edit* или *git commit -m 'merge main'*.  
  - Сделать *git push* своей ветки.
7. Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.  
8. Ещё раз обновить *main*, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: *git checkout main && git pull*.  
9. Вы великолепны! Можете начинать снова со второго пункта.  
## Алгоритм-шпаргалка для разрешения конфликтов слияния PR <br>
1. Открыть проект в IDE (VS Code, IDEA или другие).  
2. Открыть файл, в котором есть конфликт.  
3. Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.  
4. Когда конфликты разрешены, сделать коммит: *git commit --no-edit* или *git commit -m 'merge branch <название ветки>'*.  
